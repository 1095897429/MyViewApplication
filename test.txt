2019.5.29
面向对象 -- 有时不需要动到已经测试好的程序
覆盖含义是由子类重新定义继承下来的方法，改变或延伸方法
变量有两种，primitive主数据类型 和 引用
变量规则 类型 + 名称
将变量想成是杯子，将引用想成遥控器【声明一个引用变量 创建对象 连接对象和引用】
数组犹如杯架
传值给方法 实参/形参 形参和实例变量一样，想成杯子即可
Java通过值传递的，通过拷贝传递
数据隐藏 存储修饰符 private public
局部变量没有默认值
== 比较主数据类型的字节组合
== 比较两个引用是否指向同一对象
equals比较两个对象是否在意义上相等
多态下，引用可以是实际对象类型的父类 || 参数 和 返回类型也可以是多态
抽象类是让这个类不能被"new" 出来，通过abstract标记
不能在非抽象类中拥有抽象方法，标记出多态而存在
接口就好像是100%的纯抽象类
对象生存的空间堆（heap） 方法调用和局部变量（stack）栈
对象的实例变量的值存放于该对象中，位于堆上
静态变量会在该类的任何对象创建前完成初始化，在任何静态方法前初始化
5.0版加入autoboxing功能自动将主数据类型转为包装过的对象
如果try 或 catch块中有return指令，finally还是会执行！流程会跳动finally然后再回到return指令
内部类可以使用外部所有的方法与变量，就算是私有的也一样
通过fileoutputStream时，如果文件不存在，它会自动被创建出来
transient表示不被序列化
File代表磁盘上的文件，可以把它想象成文件的路径
缓存区就向逛超市没有推车一样，只能一次拿一项东西结账
ButterWritter可暂存一堆数据，然后到满时候在写入磁盘，减少对磁盘操作次数
socket是让两台机器互相认识对方的一个网络连接对象
Thread对象一旦线程的run方法完成后，该线程就不能再重新启动了
synchronized代表线程需要一把钥匙来存取被同步化过的线程

把E想成是 集合所要维护和返回的元素类型
在不寻常但可行的位置上使用未定义类型参数 <T extends Animal>
Collection主要有3个接口：List Set Map
引用相等性 对象相等性(堆上两个不同对象在意义上是相同的)
默认的equals在object.java中判断的是两个对象的地址是否相等
hashcode是获取散列码，确定该对象在散列表中的位置

2019.5.30
保持有序，推荐使用treeset,因为使用了compareble实现compareTo方法 和 comparator实现compare方法
Java RMI通信模型 如何取得不同机器上的对象来调用某个方法，客户端辅助设施称为stub，服务端辅助设施称为skeleton -- 咋感觉像binder通信相似
如何理解String的不变性，创建String时，JVM会存储在String Pool的特殊存储区
记住字符串字面量，是个常量，它存在于方法区里的常量池，方法区下有个静态区，比如static变量

总结；head first java 电子书看完
 🈶以下知识不明确
    1.网络联机知识（470页）！！！！
